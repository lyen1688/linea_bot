<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Linea 数据批量查询</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css"/>
  <style>
    body { background-color:#f8f9fa; }
    .container{ max-width:1000px; margin-top:50px; padding:30px; background:#fff; border-radius:10px; box-shadow:0 0 10px rgba(0,0,0,.1); }
    h1{ color:#333; margin-bottom:20px; text-shadow:2px 2px 4px rgba(0,0,0,.1); text-align:center; }
    .info{ margin-bottom:30px; }
    textarea{ width:100%; height:200px; margin-bottom:20px; padding:10px; border:1px solid #ced4da; border-radius:5px; resize:vertical; }
    button{ padding:10px 20px; font-size:16px; border-radius:5px; background:#007bff; color:#fff; border:none; cursor:pointer; transition:background-color .3s; }
    button:hover{ background:#0056b3; }
    #result{ margin-top:30px; }
    .summary{ font-size:18px; font-weight:bold; margin-bottom:20px; }
    .text-green{ color:green; } .text-red{ color:red; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Linea 数据批量查询</h1>
    <div class="info">
      <p>支持Linea两种不同的查询模式，更快更安全！源码已开源，你可以自己部署：<a href="https://github.com/lyen1688/linea_bot/" target="_blank">github</a></p>
      <p>重要提示：我们不会收集任何用户信息，更不会去举报女巫。你可以不用，但别诋毁。</p>
      <p class="text-green">最新更新：支持查询最新的LXP-L，支持查询LAM余额和对应的等级！</p>
      <p class="author-info">
        by：老叶1999.eth &nbsp;&nbsp;作者推特：<a href="https://x.com/1999_eth" target="_blank">https://x.com/1999_eth</a>
      </p>
      <p>如果你觉得这个工具对你有帮助，你又恰好使用OKX钱包，欢迎绑定我的<a href="https://web3.okx.com/ul/joindex?ref=1999ETH" target="_blank">OKX DEX邀请码</a>：1999ETH，你交易手续费减免20%，同时也是对我最大的支持！</p>
    </div>

    <div class="mb-3">
      <textarea class="form-control" placeholder="输入地址列表,每行一个地址" id="address-input"></textarea>
    </div>

    <div class="mb-3">
      <label class="form-label bold-label mb-2">查询方式：</label>
      <div class="form-check mb-2">
        <input class="form-check-input" type="radio" name="addressType" id="localQuery" value="local" checked>
        <label class="form-check-label" for="localQuery">
          本地查询：直连官方API接口，不经过其他任何服务器！你的IP地址对官方可见！
        </label>
      </div>
      <div class="form-check">
        <input class="form-check-input" type="radio" name="addressType" id="proxyQuery" value="proxy">
        <label class="form-check-label" for="proxyQuery">
          代理查询：通过统一的代理服务器查询，上百万地址都同一个IP！你的IP地址官方不可见！
        </label>
      </div>
    </div>

    <div class="d-grid">
      <button class="btn btn-primary" type="button" id="query-btn">
        <i class="bi bi-search"></i> 批量查询
      </button>
    </div>

    <div id="result"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- 新增：ethers.js 用于 ABI 编解码 Multicall3 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <script>
    const addressInput = document.getElementById('address-input');
    const queryBtn = document.getElementById('query-btn');
    const resultDiv = document.getElementById('result');

    // 常量：代币与Multicall
    const RPC_URL = 'https://rpc.linea.build/';
    const MULTICALL3 = '0xca11bde05977b3631167028862be2a173976ca11'; // Multicall3
    const TOKEN_E158 = '0xE158CaCCe6f5713f5739A7d7AF0dB60116187687'; // LAM代币
    const DECIMALS_E158 = 18; // 假设18位，如需严谨可再加一次性查询decimals
    const TOKEN_LXP = '0xd83af4fbd77f3ab65c3b1dc4b38d7e67aecf599a'; // LXP代币
    const DECIMALS_LXP = 18;
    const TOKEN_LXPL = '0xbc8f4663470229fd4ca3686a24792d93dd800216'; // LXP-L代币
    const DECIMALS_LXPL = 18;

    // ethers Interface（只放需要的函数签名）
    const ifaceERC20 = new ethers.utils.Interface([
      'function balanceOf(address) view returns (uint256)'
    ]);
    const ifaceMC3 = new ethers.utils.Interface([
      'function aggregate3(tuple(address target,bool allowFailure,bytes callData)[] calls) payable returns (tuple(bool success, bytes returnData)[] returnData)'
    ]);

    // LAM等级对应表（原始值 * 10^12）
    const LAM_TIERS = [
      { tier: 1, value: 1491 },
      { tier: 2, value: 1640 },
      { tier: 3, value: 1789 },
      { tier: 4, value: 1938 },
      { tier: 5, value: 2461 },
      { tier: 6, value: 2640 },
      { tier: 7, value: 2684 },
      { tier: 8, value: 3132 },
      { tier: 9, value: 4474 },
      { tier: 10, value: 4847 },
      { tier: 11, value: 7605 },
      { tier: 12, value: 8053 },
      { tier: 13, value: 8547 },
      { tier: 14, value: 8724 },
      { tier: 15, value: 9209 }
    ];

    // 根据LAM余额判断等级
    function getLAMTier(lamValue) {
      if (!lamValue || lamValue <= 0) return '';
      
      // 找到最接近的等级
      for (let i = 0; i < LAM_TIERS.length; i++) {
        if (lamValue <= LAM_TIERS[i].value) {
          return LAM_TIERS[i].tier;
        }
      }
      // 如果超过最高等级，返回15
      return 15;
    }

    // 计算预估空投：LXP * LAM（18位精度）* 1000000000
    function calculateAirdrop(index) {
      const lxpCell = document.getElementById('lxp-' + index);
      const e158Cell = document.getElementById('e158-' + index);
      const airdropCell = document.getElementById('airdrop-' + index);
      
      if (!lxpCell || !e158Cell || !airdropCell) return;
      
      const lxpText = lxpCell.textContent;
      const e158Text = e158Cell.textContent;
      
      // 检查是否都是有效数字
      if (lxpText === 'Error' || e158Text === 'Error' || 
          lxpText === '正在查询...' || e158Text === '正在查询...' ||
          e158Text === '0' || !e158Text) {
        airdropCell.textContent = '-';
        return;
      }
      
      const lxp = parseFloat(lxpText) || 0;
      const lamDisplay = parseFloat(e158Text) || 0; // 这是12位精度的显示值
      
      if (lxp <= 0 || lamDisplay <= 0) {
        airdropCell.textContent = '-';
        return;
      }
      
      // 将显示值转换回18位精度：lamDisplay / 10^12 * 10^18 = lamDisplay * 10^6
      const lamFull = lamDisplay * Math.pow(10, 6);
      const lamOriginal = lamFull / Math.pow(10, 18); // 转换为原始小数值
      
      // 计算：LXP * LAM（18位精度）* 1000000000
      const airdrop = lxp * lamOriginal * 1000000000;
      
      airdropCell.textContent = airdrop.toFixed(2);
      
      // 累计到总计中
      totalSummary.airdropTotal += airdrop;
    }

    // 累计信息
    let totalSummary = {
      walletCount: 0,
      lxpTotal: 0,
      lxplTotal: 0,
      pohNormal: 0,
      pohAbnormal: 0,
      airdropTotal: 0
    };

    queryBtn.addEventListener('click', function () {
      let addresses = addressInput.value
        .split('\n')
        .map(s => s.trim())
        .filter(address => address && address.startsWith('0x'))
        .map(a => a.toLowerCase());

      // 重置累计
      totalSummary = {
        walletCount: addresses.length,
        lxpTotal: 0,
        lxplTotal: 0,
        pohNormal: 0,
        pohAbnormal: 0,
        airdropTotal: 0
      };

      // 清空结果
      resultDiv.innerHTML = '';

      // 累计栏容器
      let summaryContainer = document.getElementById('total-summary-container');
      if (!summaryContainer) {
        summaryContainer = document.createElement('div');
        summaryContainer.className = 'd-flex justify-content-between align-items-center mb-3 mt-4';
        summaryContainer.id = 'total-summary-container';
        resultDiv.parentNode.insertBefore(summaryContainer, resultDiv);
      } else {
        summaryContainer.innerHTML = '';
      }

      let totalSummarySpan = document.createElement('span');
      totalSummarySpan.id = 'total-summary';
      totalSummarySpan.textContent = '正在查询...';
      summaryContainer.appendChild(totalSummarySpan);

      // 表头：新增 “E158余额”
      let resultTable = document.createElement('table');
      resultTable.className = 'table table-striped';
      resultTable.innerHTML =
        '<thead><tr>' +
        '<th>编号</th><th>钱包地址</th><th>LXP</th><th>LXP-L</th><th>LAM余额</th><th>等级</th><th>POH状态</th><th>预估空投</th>' +
        '</tr></thead><tbody></tbody>';

      const tbody = resultTable.querySelector('tbody');

      addresses.forEach((address, index) => {
        const row = tbody.insertRow(-1);
        row.id = 'address-row-' + index;

        row.insertCell(0).textContent = index + 1;              // 编号
        row.insertCell(1).textContent = address;                 // 地址

        const lxpTd = row.insertCell(2); lxpTd.id   = 'lxp-' + index;
        const lxplTd= row.insertCell(3); lxplTd.id  = 'lxpl-' + index;
        const e158Td= row.insertCell(4); e158Td.id  = 'e158-' + index; // LAM余额列
        const tierTd= row.insertCell(5); tierTd.id  = 'tier-' + index; // 等级列
        const pohTd = row.insertCell(6); pohTd.id   = 'poh-' + index;
        const airdropTd= row.insertCell(7); airdropTd.id = 'airdrop-' + index; // 预估空投列

        lxpTd.textContent = '正在查询...';
        lxplTd.textContent = '正在查询...';
        e158Td.textContent = '正在查询...';
        tierTd.textContent = '正在查询...';
        airdropTd.textContent = '正在查询...';
        pohTd.textContent = '正在查询...';
      });

      resultDiv.appendChild(resultTable);

      const queryType = document.querySelector('input[name="addressType"]:checked').value;
      if (queryType === 'local') {
        processBatch(addresses, 0, 5); // 并发5
      } else {
        processProxyBatches(addresses, 0, 5);
      }
    });

    // —— 本地模式 —— //
    async function processBatch(addresses, startIndex, batchSize) {
      const endIndex = Math.min(startIndex + batchSize, addresses.length);
      const batch = addresses.slice(startIndex, endIndex);

      // 并发：LXP批量查询 + LXP-L批量查询 + LAM批量查询 + 其他单个查询
      const lxpBatchReq = fetchLXPBalancesByMulticall(batch, startIndex);
      const lxplBatchReq = fetchLXPLBalancesByMulticall(batch, startIndex);
      const e158BatchReq = fetchE158BalancesByMulticall(batch, startIndex);
      const otherRequestsPerAddress = batch.map((address, i) => fetchOtherAddressData(address, startIndex + i));

      await Promise.all([lxpBatchReq, lxplBatchReq, e158BatchReq, ...otherRequestsPerAddress]);

      if (endIndex < addresses.length) {
        processBatch(addresses, endIndex, batchSize);
      } else {
        updateTotalSummary();
        addExportButton();
      }
    }

    // 新增：使用 Multicall3 批量查询本批地址的 LXP 余额
    async function fetchLXPBalancesByMulticall(batchAddresses, startIndex) {
      try {
        // 构造 calls: 对LXP代币合约的 balanceOf(address)
        const calls = batchAddresses.map(addr => ({
          target: TOKEN_LXP,
          allowFailure: true,
          callData: ifaceERC20.encodeFunctionData('balanceOf', [addr])
        }));

        const data = ifaceMC3.encodeFunctionData('aggregate3', [calls]);

        const resp = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            method: 'eth_call',
            params: [{ to: MULTICALL3, data }, 'latest'],
            id: 889,
            jsonrpc: '2.0'
          })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const { result } = await resp.json();

        const decoded = ifaceMC3.decodeFunctionResult('aggregate3', result)[0]; // returnData[]
        decoded.forEach((r, i) => {
          const actualIndex = startIndex + i;
          const cell = document.getElementById('lxp-' + actualIndex);
          if (!cell) return;

          if (!r.success) {
            cell.textContent = 'Error';
            return;
          }
          try {
            const [raw] = ifaceERC20.decodeFunctionResult('balanceOf', r.returnData);
            const val = Number(ethers.utils.formatUnits(raw, DECIMALS_LXP));
            // LXP显示为整数
            const intVal = Math.floor(val);
            cell.textContent = intVal.toString();
            totalSummary.lxpTotal += intVal;
            // 计算预估空投
            calculateAirdrop(actualIndex);
          } catch {
            cell.textContent = 'Error';
            // LXP错误时，预估空投也设为错误
            const airdropCell = document.getElementById('airdrop-' + actualIndex);
            if (airdropCell) airdropCell.textContent = '-';
          }
        });
        updateTotalSummary();
      } catch (e) {
        // 整批失败则把批内单元格标注为 Error
        batchAddresses.forEach((_, i) => {
          const cell = document.getElementById('lxp-' + (startIndex + i));
          if (cell) cell.textContent = 'Error';
        });
      }
    }

    // 新增：使用 Multicall3 批量查询本批地址的 LXP-L 余额
    async function fetchLXPLBalancesByMulticall(batchAddresses, startIndex) {
      try {
        // 构造 calls: 对LXP-L代币合约的 balanceOf(address)
        const calls = batchAddresses.map(addr => ({
          target: TOKEN_LXPL,
          allowFailure: true,
          callData: ifaceERC20.encodeFunctionData('balanceOf', [addr])
        }));

        const data = ifaceMC3.encodeFunctionData('aggregate3', [calls]);

        const resp = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            method: 'eth_call',
            params: [{ to: MULTICALL3, data }, 'latest'],
            id: 890,
            jsonrpc: '2.0'
          })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const { result } = await resp.json();

        const decoded = ifaceMC3.decodeFunctionResult('aggregate3', result)[0]; // returnData[]
        decoded.forEach((r, i) => {
          const actualIndex = startIndex + i;
          const lxplCell = document.getElementById('lxpl-' + actualIndex);
          if (!lxplCell) return;

          if (!r.success) {
            lxplCell.textContent = 'Error';
            return;
          }
          try {
            const [raw] = ifaceERC20.decodeFunctionResult('balanceOf', r.returnData);
            const val = Number(ethers.utils.formatUnits(raw, DECIMALS_LXPL));
            // LXP-L显示为整数
            const intVal = Math.floor(val);
            lxplCell.textContent = intVal.toString();
            totalSummary.lxplTotal += intVal;
          } catch {
            lxplCell.textContent = 'Error';
          }
        });
        updateTotalSummary();
      } catch (e) {
        // 整批失败则把批内单元格标注为 Error
        batchAddresses.forEach((_, i) => {
          const cell = document.getElementById('lxpl-' + (startIndex + i));
          if (cell) cell.textContent = 'Error';
        });
      }
    }

    // 单地址其他数据查询（POH）
    async function fetchOtherAddressData(address, index) {
      const lower = address.toLowerCase();

      // POH查询
      try {
        const resp = await fetch(`https://linea-xp-poh-api.linea.build/poh/${lower}`);
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        const ok = !!data.poh;
        const td = document.getElementById('poh-' + index);
        td.textContent = ok ? '正常' : '无';
        td.className = ok ? 'text-green' : '';
        if (ok) totalSummary.pohNormal += 1; else totalSummary.pohAbnormal += 1;
      } catch(e) {
        const td = document.getElementById('poh-' + index);
        td.textContent = '无';
        td.className = '';
        totalSummary.pohAbnormal += 1;
      }

      updateTotalSummary();
    }

    // 新增：使用 Multicall3 批量查询本批地址的 E158 余额
    async function fetchE158BalancesByMulticall(batchAddresses, startIndex) {
      try {
        // 构造 calls: 对同一代币合约 TOKEN_E158 的 balanceOf(address)
        const calls = batchAddresses.map(addr => ({
          target: TOKEN_E158,
          allowFailure: true,
          callData: ifaceERC20.encodeFunctionData('balanceOf', [addr])
        }));

        const data = ifaceMC3.encodeFunctionData('aggregate3', [calls]);

        const resp = await fetch(RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            method: 'eth_call',
            params: [{ to: MULTICALL3, data }, 'latest'],
            id: 888,
            jsonrpc: '2.0'
          })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const { result } = await resp.json();

        const decoded = ifaceMC3.decodeFunctionResult('aggregate3', result)[0]; // returnData[]
        decoded.forEach((r, i) => {
          const actualIndex = startIndex + i;
          const cell = document.getElementById('e158-' + actualIndex);
          const tierCell = document.getElementById('tier-' + actualIndex);
          if (!cell) return;

          if (!r.success) {
            cell.textContent = 'Error';
            if (tierCell) tierCell.textContent = '';
            return;
          }
          try {
            const [raw] = ifaceERC20.decodeFunctionResult('balanceOf', r.returnData);
            const val = Number(ethers.utils.formatUnits(raw, DECIMALS_E158));
            if (isFinite(val) && val > 0) {
              // 18位精度只显示前12位，去掉后6位
              const multiplied = val * Math.pow(10, 12);
              const lamValue = Math.floor(multiplied);
              cell.textContent = lamValue.toString();
              // 设置对应的等级
              if (tierCell) {
                const tier = getLAMTier(lamValue);
                tierCell.textContent = tier ? `Tier${tier}` : '';
              }
              // 计算预估空投
              calculateAirdrop(actualIndex);
                          } else {
                cell.textContent = '0';
                if (tierCell) tierCell.textContent = '';
                // LAM为0时，预估空投显示为-
                const airdropCell = document.getElementById('airdrop-' + actualIndex);
                if (airdropCell) airdropCell.textContent = '-';
              }
                      } catch {
              cell.textContent = 'Error';
              if (tierCell) tierCell.textContent = '';
              // LAM错误时，预估空投也设为错误
              const airdropCell = document.getElementById('airdrop-' + actualIndex);
              if (airdropCell) airdropCell.textContent = '-';
            }
        });
      } catch (e) {
        // 整批失败则把批内单元格标注为 Error
        batchAddresses.forEach((_, i) => {
          const cell = document.getElementById('e158-' + (startIndex + i));
          if (cell) cell.textContent = 'Error';
        });
      }
    }

    // —— 代理模式 —— //
    async function processProxyBatches(addresses, startIndex, batchSize) {
      const endIndex = Math.min(startIndex + batchSize, addresses.length);
      const batch = addresses.slice(startIndex, endIndex);

      // 代理接口 + 批量 LXP + 批量 LXP-L + 批量 LAM
      await Promise.all([
        proxyQuery(batch, startIndex),
        fetchLXPBalancesByMulticall(batch, startIndex),
        fetchLXPLBalancesByMulticall(batch, startIndex),
        fetchE158BalancesByMulticall(batch, startIndex)
      ]);

      if (endIndex < addresses.length) {
        processProxyBatches(addresses, endIndex, batchSize);
      } else {
        updateTotalSummary();
        addExportButton();
      }
    }

    async function proxyQuery(batch, startIndex) {
      try {
        const proxyResponse = await fetch('https://linea-bot-aqgghflcjv.cn-hangzhou.fcapp.run/getWalletInfo', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wallet_addresses: batch })
        });

        if (!proxyResponse.ok) throw new Error('HTTP ' + proxyResponse.status);
        const data = await proxyResponse.json();

        data.forEach((result, i) => {
          const actualIndex = startIndex + i;

          const pohTd  = document.getElementById('poh-' + actualIndex);

          if (result.error) {
            if (pohTd)  { pohTd.textContent = '无'; pohTd.className = ''; }
            totalSummary.pohAbnormal += 1;
          } else {
            if (pohTd)  {
              const isOk = result.poh === '正常';
              pohTd.textContent = isOk ? '正常' : '无';
              pohTd.className = isOk ? 'text-green' : '';
              if (isOk) totalSummary.pohNormal += 1; else totalSummary.pohAbnormal += 1;
            }
          }
        });

        updateTotalSummary();
        addExportButton();
      } catch (e) {
        console.error('Proxy error:', e);
      }
    }



    // UI：累计 + 导出
    function updateTotalSummary() {
      const el = document.getElementById('total-summary');
      if (!el) return;
      el.innerHTML = `
        钱包数量：<span class="text-green">${totalSummary.walletCount}</span> 个 |
        LXP：<span class="text-green">${totalSummary.lxpTotal}</span> 分 |
        LXP-L：<span class="text-green">${totalSummary.lxplTotal}</span> 分 |
        POH正常：<span class="text-green">${totalSummary.pohNormal}</span> 个 |
        暂无POH：${totalSummary.pohAbnormal} 个 |
        预估空投：<span class="text-green">${totalSummary.airdropTotal.toFixed(2)}</span>
      `;
    }

    function addExportButton() {
      let exportBtn = document.getElementById('export-btn');
      if (!exportBtn) {
        exportBtn = document.createElement('button');
        exportBtn.className = 'btn btn-secondary';
        exportBtn.id = 'export-btn';
        exportBtn.textContent = '导出表格';
        exportBtn.addEventListener('click', exportToCSV);
        document.getElementById('total-summary-container').appendChild(exportBtn);
      }
    }

    function exportToCSV() {
      const addresses = addressInput.value.split('\n').filter(a => a.trim() !== '' && a.startsWith('0x'));
      let csvContent = "data:text/csv; charset=utf-8," + "编号,钱包地址,LXP,LXP-L,LAM余额,等级,POH状态,预估空投\n";
      addresses.forEach((address, index) => {
        const lxp  = document.getElementById('lxp-' + index).textContent;
        const lxpl = document.getElementById('lxpl-' + index).textContent;
        const e158 = document.getElementById('e158-' + index).textContent;
        const tier = document.getElementById('tier-' + index).textContent;
        const poh  = document.getElementById('poh-' + index).textContent;
        const airdrop = document.getElementById('airdrop-' + index).textContent;
        csvContent += `${index + 1},${address},${lxp},${lxpl},${e158},${tier},${poh},${airdrop}\n`;
      });
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement('a');
      link.setAttribute('href', encodedUri);
      link.setAttribute('download', 'wallet_balances.csv');
      document.body.appendChild(link);
      link.click();
    }
  </script>
</body>
</html>
